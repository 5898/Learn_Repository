### iframe异常捕获
只能用window.onerror
```javascript
window.onerror = function(message, source, lineno, colno, error) {
  console.log('捕获到异常：',{message, source, lineno, colno, error});
}
```



### elementUI Table样式
表格固定列功能：表头由两个head叠加，一个固定列和一个底部普通列，
css不能直接更改改表头样式，1.两表头高度宽度可能不一致，css修改有遗漏2.每次拉动表头列宽度，elementUI会用js重绘表头
```
// 固定列和普通列
.has-gutter .cell, .bgGray .cell {}
```

### Vue created和mounted
页面：created，mountded 加载一次
组件：mounted可能加载多次
created 必定在mounted前执行，但不一定在mounted前执行完

### Vue 使用$nextTick
```javascript
// 组件内使用
this.$nextTick(function () {
  console.log(this.$el.textContent) // => 'dom已更新'
})
```
在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM
Vue更新dow是异步的，只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用。

### elementUI Tree自定义节点内容
使用renderContent自定义节点内容时，官方的模板写法中文本内容可以使用变量，但class无法使用变量。
```html
<el-tree
  :data="data"
  show-checkbox
  node-key="id"
  default-expand-all
  :expand-on-click-node="false"
  :render-content="renderContent">
</el-tree>
```
```js
renderContent(h, { node, data, store }) {
  let test="111";
  return (
    <span class="custom-tree-node">
      // 错误，class无法使用变量
      <span class="{test}">{node.label}</span>
      <span class="{{test}}">{node.label}</span>
      // 正确
      <span>{node.label}</span>
      <span>
        <el-button size="mini" type="text" on-click={ () => this.append(data) }>Append</el-button>
        <el-button size="mini" type="text" on-click={ () => this.remove(node, data) }>Delete</el-button>
      </span>
    </span>);
}
```
class使用变量写法，使用创建节点函数：
```js
// 例1
renderContent:function(createElement, { node, data, store }) {
  var self = this;
  return createElement('span', [
    createElement('span', node.label),
    createElement('span', {attrs:{
      style:"float: right; margin-right: 200px"
    }},[
      createElement('el-button',{
      attrs:{
        size:"mini"
      },
      on:{
        click:function() {
          console.info("点击了节点" + data.id + "的添加按钮");
          store.append({ id: self.baseId++, label: 'testtest', children: [] }, data);
        }
      }},"添加"),
      createElement('el-button',{attrs:{
        size:"mini"
      },on:{
        click:function() {
          console.info("点击了节点" + data.id + "的删除按钮");
          store.remove(data);
        }
      }},"删除"),
    ]),
  ]);
}
// 例2
renderContent (h, { root, node, data }) {
  if (node.node.selected) {
    return h('div', {
      class: ['ivu-tree-title', 'ivu-tree-title-selected'],
      on: {
        click: (e) => {
          let thisClassName = e.target.className
          let parentClassName = e.target.parentNode.className
          let o = this.changeNode(thisClassName, parentClassName)
          node.node.selected = o.selected
          if (thisClassName === o.otherClassName) {
            e.target.className = o.className
          } else if (parentClassName === o.otherClassName) {
            e.target.parentNode.className = o.className
          }
          this.OnSelect(node)
        }
      }
    },
    [
      h('Icon', {
        props: {
          type: this.iconType(node.node.hasChild, node.node.expand)
        }
      }),
      h('span', data.title),
      h('Icon', {
        props: {
          type: 'md-checkmark'
        }
      })
    ])
  } else {
    return h('div', {
      class: ['ivu-tree-title'],
      on: {
        click: (e) => {
          let thisClassName = e.target.className
          let parentClassName = e.target.parentNode.className
          let o = this.changeNode(thisClassName, parentClassName)
          node.node.selected = o.selected
          if (thisClassName === o.otherClassName) {
            e.target.className = o.className
          } else if (parentClassName === o.otherClassName) {
            e.target.parentNode.className = o.className
          }
          this.OnSelect(node)
        }
      }
    },
    [
      h('Icon', {
        props: {
          type: this.iconType(node.node.hasChild, node.node.expand)
        }
      }),
      h('span', data.title),
      h('Icon', {
        props: {
          type: 'md-checkmark'
        }
      })
    ])
  }
}

// 例3，自定义巡检点树
renderContent (h, { node, data, store }) {
  let alarmLevel = data.alarmLevel || 0;
  return h("span", [
    h("i", {
      class: ["icon-tree-" + alarmLevel],
    }),
    h("span", node.label)
  ]);
}
```
### elementUI Table样式
表格table样式高度建议使用行内写法，否则使用固定列和表头等功能时，会出现只有中间滚动，固定列和表头不能滚动
```html
<!-- 正确 -->
<el-table height="700px">
  <el-table-column prop="aaa" label="a"></el-table-column>
  <el-table-column prop="bbb" label="b"></el-table-column>
</el-table>

<!-- 错误 -->
<el-table class="ownTableStyle">
  <el-table-column prop="aaa" label="a"></el-table-column>
  <el-table-column prop="bbb" label="b"></el-table-column>
</el-table>

.ownTableStyle{
  height: 700px;
}
```


### elementUI Table筛选功能
表格慎用v-if,如下有可能筛选图标不显示功能不可用
```html
<!-- 错误 -->
<el-table v-if="a">
  <el-table-column prop="levelName" label="告警等级" min-width="120px" align="center"
  column-key="levelName"
  :filters="[{text: '正常', value: '正常'}, {text: '预警', value: '预警'}, {text: '一般告警', value: '一般告警'}, {text: '严重告警', value: '严重告警'}, {text: '危急告警', value: '危急告警'}]"
  ></el-table-column>
</el-table>

<el-table v-else>
  <el-table-column prop="levelName" label="告警等级" min-width="120px" align="center"
  column-key="levelName"
  :filters="[{text: '正常', value: '正常'}, {text: '预警', value: '预警'}, {text: '一般告警', value: '一般告警'}, {text: '严重告警', value: '严重告警'}, {text: '危急告警', value: '危急告警'}]"
  ></el-table-column>
</el-table>
```
解决办法：使用v-show

